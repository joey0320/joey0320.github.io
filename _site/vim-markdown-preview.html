<hr />

<p>layout: post
title:  "Gem5 simulator"
date:   2021-02-04T14:25:52-05:00
author: Joonho Hwangbo </p>

<h2>categories: Container</h2>

<h1>Gem5 simulator</h1>

<ul>
<li>references : https://www.gem5.org/documentation</li>
</ul>

<h2>what is gem5?</h2>

<p>gem5 is a modular discrete event driven computer system simulator platform. That means that:</p>

<ul>
<li>gem5’s components can be rearranged, parameterized, extended or replaced easily to suit your needs.</li>
<li>It simulates the passing of time as a series of discrete events.</li>
<li>Its intended use is to simulate one or more computer systems in various ways.</li>
<li>It’s more than just a simulator; it’s a simulator platform that lets you use as many of its premade components as you want to build up your own simulation system.</li>
</ul>

<h2>Building Gem5</h2>

<ul>
<li><p>I made a docker image that has most dependencies installed (we have to install qemu-system-x86 in the future for full system simulation)</p></li>
<li><p><code>docker pull joonho0320/v4</code></p></li>
<li><p><code>docker run -it \
--device=/dev/kvm \
--workdir="home/$USER" \
-v /home/$USER/:/home/$USER/ \
-v var/run/docker.sock:/var/run/docker.sock \
joonho0320/v4 \
-c "apt-get update ; apt-get install docker.io -y ; bash"</code></p></li>
<li><p>mount docker.sock to enable docker inside the container</p></li>
<li><p>Now the environment for building and running Gem5 is all set!!!</p></li>
<li><p><code>scons build/&lt;ISA&gt;/gem5.opt -j20</code></p>

<ul>
<li><ISA> should be the ISA that you want to build and run</li>
<li>e.g. <code>scons build/X86/gem5.opt -j20</code></li>
</ul></li>
<li><p>output binary types</p>

<ul>
<li><code>opt</code> : debugging and most optimizations (just use this ...)</li>
<li><code>debug</code> : no optimizations and debug symbols</li>
<li><code>fast</code></li>
<li><code>prof and perf</code></li>
</ul></li>
</ul>

<h2>Creating a simple configuration script</h2>

<ul>
<li><p>The gem5 binary takes, as a parameter, a python script which sets up and executes the simulation. In this script, you create a system to simulate, create all of the components of the system, and specify all of the parameters for the system components. Then, from the script, you can begin the simulation.</p></li>
<li><p>gem5’s modular design is built around the SimObject type</p></li>
<li>Most of the components in the simulated system are SimObjects: CPUs, caches, memory controllers, buses, etc.</li>
<li><p>gem5 exports all of these objects from their C++ implementation to python</p></li>
<li><p>key point : gem5 objects are built from C++ implementation</p></li>
</ul>

<p>``` python3
import m5
from m5.objects import *</p>

<p>[comment]:  the system object will be the parent of all other objects
[comment]:  in the simulated system
[comment]:  it contains alot of functional information (e.g. physical memory ranges, root clock domain, kernel ...)
system = System()</p>

<p>[comment]:  set clock domain
system.clk<em>domain = SrcClockDomain()
system.clk</em>domain.clock = '1GHz'
system.clk<em>domain.voltage</em>domain = VoltageDomain()</p>

<p>[comment]:  set memory : memory is usually timing mode
system.mem<em>mode = 'timing'
system.mem</em>ranges = [AddrRange('512MB')]</p>

<p>[comment]:  set cpu
system.cpu = TimingSimpleCPU()</p>

<p>[comment]:  set systemwide memory bus
system.membus = SystemXBar()</p>

<p>[comment]:  no cache system
[comment]:  directly connect caches to the membus
[comment]:  memobject1.master = memobject1.slave
[comment]:  master sends requeset
[comment]:  slave sends the responses
system.cpu.icache<em>port = system.membus.slave
system.cpu.dcache</em>port = system.membus.slave</p>

<p>[comment]:  only required for X86
[comment]:  create IO controller on the cpu
[comment]:  and connect it to the mem bus
system.cpu.createInterruptController()
system.cpu.interrupts[0].pio = system.membus.master
system.cpu.interrupts[0].int<em>master = system.membus.slave
system.cpu.interrupts[0].int</em>slave = system.membus.master</p>

<p>system.system_port = system.membus.slave</p>

<p>[comment]:  create a memory controller
system.mem<em>ctrl = DDR3</em>1600<em>8x8()
system.mem</em>ctrl.range = system.mem<em>ranges[0]
system.mem</em>ctrl.port = system.membus.master</p>

<p>[comment]:  in the syscall emulation mode, we just need to pass the application binary
[comment]:  then give this process to the cpu workload
[comment]:  and finally create the functional exectuion contexts in the CPU
process = Process()
process.cmd = ['tests/test-progs/hello/bin/x86/linux/hello']
system.cpu.workload = process
system.cpu.createThreads()</p>

<p>[comment]:  finally we instantiate the system and run the simulation
root = Root(full_system=False, system=system)</p>

<p>m5.instantiate()</p>

<p>print("Beginning simulation")
exit<em>event = m5.simulate()
print("Exiting @ tick {} because {}'.format(m5.curTick(), exit</em>event.getCause()))
```</p>
